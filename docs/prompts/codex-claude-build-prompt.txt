Budujesz aplikację desktop (cross-platform) do automatycznego wyszukiwania i pobierania stock VIDEO z Freepik na podstawie pliku stockplan.json.

Twarde zasady pracy:
1) Najpierw przeczytaj: /docs/STATUS.md, /docs/ARCHITECTURE.md, /docs/WORKFLOW_FOR_AI.md oraz ostatnie ADR w /docs/DECISIONS/.
2) Zanim zmienisz kod: uruchom testy i opisz wynik w PR.
3) Implementuj tylko jedną fazę lub jeden task na PR.
4) Po zakończeniu: zaktualizuj /docs/STATUS.md (co działa, jak uruchomić, następny krok).
5) Jeśli zmieniłeś decyzję architektury: dopisz ADR.

Wymagania produktu:
- Aplikacja NIE ma wbudowanego AI. Nie używa OpenAI.
- Użytkownik generuje stockplan.json poza aplikacją (np. w ChatGPT) i wczytuje go do aplikacji.
- Aplikacja waliduje stockplan.json (JSON Schema) i odrzuca błędne dane z czytelnym raportem.
- Aplikacja używa Freepik API z x-freepik-api-key (klucz w .env lub secure storage, nigdy w repo).
- Musi mieć: dry-run i auto-run, rate limiting, retry/backoff, resume, audyt w _meta/.
- Musi tworzyć foldery scen 001, 002 itd, pobierać pliki i nazywać je czytelnie: 001_slug__freepik_id__a.mp4.
- Musi zapisywać candidates.json, selection.json, run-log.jsonl, errors.jsonl.

Scoring deterministyczny (ADR-0002):
- Hard filters: typ=video, duration w zakresie, rozdzielczość minimalna, negative terms exclusion.
- Scoring: resolution 40% (preferuj 4K), duration_fit 25%, relevance 25%, recency 10%.
- Tie-breaker: resource ID rosnąco.
- Szczegóły w docs/DECISIONS/ADR-0002-scoring-algorithm.md.

Stos technologiczny:
- Node.js + TypeScript
- Vitest (unit tests)
- Mockowanie HTTP (np. nock)
- Docelowo Electron/Tauri UI, ale pipeline najpierw działa jako CLI.

Fazy do implementacji w kolejności:
Faza 0: repo scaffold, lint/format/test, CI, docs skeleton.
Faza 0.5: spike — jeden prawdziwy call do Freepik API, zapis response jako fixture, walidacja założeń.
Faza 1: stockplan.schema.json + walidator + prompt builder screen (może być na razie CLI print).
Faza 2: FreepikClient (search videos, download, caching TTL 24h, rate limit, retry exponential backoff) + integration tests na mockach.
Faza 3: SearchRunner i deterministyczny wybór wyników, zapis candidates/selection inkrementalnie (po każdej scenie). Tryb --dry-run z preview thumbnails.
Faza 4: DownloadRunner, foldery, nazwy plików, scene.json per scena. Concurrent downloads (semaphore, domyślnie 3). Disk space check.
Faza 5: resume, lockfile, idempotencja, error journal. Graceful shutdown (SIGINT). Obsługa scen unfulfilled/partial.
Faza 6: desktop UI minimal (rozważ Tauri vs Electron).
Faza 7: packaging cross-platform (Windows EXE + macOS .app + Linux AppImage).

Teraz zrób Faza 0 jako pierwszy PR. Dodaj komendy:
- npm test
- npm run lint
- npm run stockbot -- --help
I opisz dokładnie w docs/STATUS.md jak odpalić projekt od zera.
